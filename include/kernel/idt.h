// SPDX-License-Identifier: MIT
// Author:  Giovanni Santini
// Mail:    giovanni.santini@proton.me
// Github:  @San7o

#ifndef POVOS_KERNEL_IDT_H
#define POVOS_KERNEL_IDT_H

#include <libk/stddef.h>
#include <libk/stdbool.h>

//
// Interrupt Descriptor Table
// ==========================
//
// Interrupts and exceptions are events that indicate that a condition
// exists somewhere in the system, the processor, or within the
// currently executing program or task that requires the attention of
// a processor. They typically result in a forced transfer of
// execution from the currently running program or task to a special
// software routine or task called an interrupt handler or an
// exception handler. The action taken by a processor in response to
// an interrupt or exception is referred to as servicing or handling
// the interrupt or exception.
// 
// The interrupt descriptor table (IDT) specifies to the CPU where the
// Interrupt Service Routines are located. Its entries are called
// gates, which can be of the following types:
//
//  - interrupt: used to specify an interrupt service routine, they
//    are generated at random times during the execution of a program,
//    in response from signals from hardware.
// 
//  - trap: used to handle exceptions which are generated by the CPU
//    when an error condition is detected, such as division by 0.
// 
//    Exceptions are further classified as:
// 
//    - faults: an exception that can be generally be corrected and
//       that, once corrected, allows the program to be restarted with
//       no loss of continuity.
// 
//     - traps: an exception that is reported immediately following
//       the execution of the trapping instruciton.
// 
//     - abort: an exception that does not always report the precise
//       location of the instruction causing the exception
// 
//  - task: used for hardware taks switching (removed in x86_64)
//

// Gates
// -----
//
// An entry in the IDT (which is called a "gate") has the following
// structure:
typedef struct __attribute__((packed)) idt_gate {
    u16_t base_low;       // Low 16 bits of the address to jump to
    u16_t cs_selector;    // Code segment selector
    u8_t  ist;            // bits 0..2 holds Interrupt Stack Table
                          // offset, rest of bits zero
    u8_t  attributes;     // Flag bytes
                          //  - Bit 7:     present bit, always 1
                          //  - Bits 6-5:  Privelege level of caller
                          //               (0=kernel..3=user)
                          //  - Bit 4:     Set to 0 for interrupt gates
                          //  - Bits 3-0:  0b1111 for trap, 0b1110 for
                          //               interrupts
    u16_t base_middle;    // Middle 16 bits of the address to jump to
    u32_t base_high;      // High 16 bits of the address to jump to
    u32_t reserved;       // Must always be 0
} idt_gate_t;

//
// The `Gate Type` is a 4-bit value which defines the type of gate
// this Interrupt Descriptor represents. In long mode there are two
// valid type values:
// 
//   - 0b1110 or 0xE: 64-bit Interrupt Gate
//   - 0b1111 or 0xF: 64-bit Trap Gate
// 
// `DPL` is a 2-bit value which defines the CPU Privilege Levels which
// are allowed to access this interrupt via the INT
// instruction. Hardware interrupts ignore this mechanism.
//
// `P` is the present bit. Must be set (1) for the descriptor to be
// valid.
//

//
// Table
// -----
//
// There are 256 interrupt vectors, so the IDT should have 256 entries
// (gates), each gate corresponding to a specific interrupt vector.
#define IDT_ENTRIES   256

// On 64-bit processors, the entries in the IDT are 16 bytes long and
// form a table like this:
//
//              + ------------------------------ +
//              | Address            | Content   |
//              | ================== | ========= |
//              | IDTR Offset + 0    | Entry 0   |
//              | IDTR Offset + 16   | Entry 1   |
//              | IDTR Offset + 32   | Entry 2   |
//              | ...                | ...       |
//              | IDTR Offset + 4080 | Entry 255 |
//              + ------------------------------ +
//
// The corresponsing entry for a given interrupt vector is pointed to
// in memory by scaling the vector by 16 and adding it to the value in
// the offset field in the IDTR.
extern idt_gate_t idt[IDT_ENTRIES];

// 
// Location
// --------
// 
// The location of the IDT is kept in IDTR (IDT register) which is
// loaded using the LIDT assembly instruciton, whose argument is a
// pointer to an IDT descriptor structure:
//
//                    + ------------------ +
//                    | 79 -- 16 | 15 -- 0 |
//                    | ======== | ======= |
//                    | offset   | size    |
//                    + ------------------ +
// 
// Where size is one less than the size of the IDT is bytes, and
// offset is the linear address of the IDT (not the physical address,
// paging applies).
//
typedef struct __attribute__((packed)) idt_descriptor {
  u16_t          size;     // 1 - sizeof(idt_interrupt_gate_64)
  u64_t          offset;   // address of idt
} idt_descriptor_t;

extern idt_descriptor_t idt_descriptor;

//
// Interrupt Service Routines
// --------------------------
//
// Interrupt Service Routines must return from the interrupt using the
// 'iretq' instruction.
//
// When the CPU calls the interrupt handlers, it changes the value of
// the stack pointer to the IST (if specified). It then pushes these
// values in this order: SS:RSP (original stack pointer), RFLAGS, CS
// (code segment), RIP. CS is padded to form a quadword.
// 
// If the interrupt is an exception, the CPU will push an error code
// onto the stack, padded with bytes to form a quadword.
//
// The isr functions are implemented in assembly.
//
void isr0(void);
void isr1(void);
void isr2(void);
void isr3(void);
void isr4(void);
void isr5(void);
void isr6(void);
void isr7(void);
void isr8(void);
void isr9(void);
void isr10(void);
void isr11(void);
void isr12(void);
void isr13(void);
void isr14(void);
void isr15(void);
void isr16(void);
void isr17(void);
void isr18(void);
void isr19(void);
void isr20(void);
void isr21(void);
void isr22(void);
void isr23(void);
void isr24(void);
void isr25(void);
void isr26(void);
void isr27(void);
void isr28(void);
void isr29(void);
void isr30(void);
void isr31(void);
void isr32(void);
void isr33(void);

//
// List of interrupts
// ------------------
//
// Here is a list of some exceptions and interrupts for x86_64:
//
// + ----------------------------------------------------------------- +
// | Num  | Type       | Name            | Source                      |
// | ==== | ========== | =============== | =========================== |
// | 0x00 | Fault      | Divide Error    | Integer divide instructions |
// | 0x01 | Trap/Fault | Debug Exception | Instruction, data, and I/0  |
// |      |            |                 | breakpoints.                |
// | 0x02 | Interrupt  | NMI Interrupt   | Nonmaskable external irq.   |
// | 0x03 | Trap       | Breakpoint      | int3 instruction            |
// | 0x04 | Trap       | Overflow        | int0 instruciton            |
// | ...  | ...        | ...             | ...                         |
// + ----------------------------------------------------------------- +
//
// For the full list goto the Intel manual, Volume 3 chapter 7.
// 

//
// Functions
//

// Set an entry in the idt
void idt_set_gate(u8_t  gate_number,
                  u64_t isr_address,
                  bool  is_trap);
// Setup the gates and load the IDT
void idt_set(void);
// Load the IDT in the CPU
void idt_load(u64_t idt_descriptor_address);

#endif // POVOS_KERNEL_IDT_H
