  ;; -----------------------------------------------------------------
  ;;
  ;; Interrupt Descriptor Table
  ;; ==========================
  ;;
  ;; Interrupts and exceptions are events that indicate that a
  ;; condition exists somewhere in the system, the processor, or
  ;; within the currently executing program or task that requires the
  ;; attention of a processor. They typically result in a forced
  ;; transfer of execution from the currently running program or task
  ;; to a special software routine or task called an interrupt handler
  ;; or an exception handler. The action taken by a processor in
  ;; response to an interrupt or exception is referred to as servicing
  ;; or handling the interrupt or exception.
  ;; 
  ;; The interrupt descriptor table (IDT) specifies to the CPU where
  ;; the Interrupt Service Routines are located. Its entries are
  ;; called gates, which can be of the following types:
  ;;
  ;;  - *interrupt*: used to specify an interrupt service routine,
  ;;      they are generated at random times during the execution of a
  ;;      program, in response from signals from hardware.
  ;; 
  ;;  - *trap*: used to handle exceptions which are generated by the
  ;;      CPU when an error condition is detected, such as division by
  ;;      0.
  ;; 
  ;;      Exceptions are further classified as:
  ;; 
  ;;        - *faults*: an exception that can be generally be
  ;;             corrected and that, once corrected, allows the
  ;;             program to be restarted with no loss of continuity.
  ;; 
  ;;        - *traps*: an exception that is reported immediately
  ;;             following the execution of the trapping instruciton.
  ;; 
  ;;        - *abort*: an exception that does not always report the
  ;;             precise location of the instruction causing the
  ;;             exception
  ;; 
  ;;  - *task: used for hardware taks switching (removed in x86_64)
  ;;
  ;; 
  ;; Location
  ;; --------
  ;; 
  ;; The location of the IDT is kept in IDTR (IDT register) which is
  ;; loaded using the LIDT assembly instruciton, whose argument is a
  ;; pointer to an IDT descriptor structure:
  ;;
  ;;                    + ------------------ +
  ;;                    | 79 -- 16 | 15 -- 0 |
  ;;                    | ======== | ======= |
  ;;                    | offset   | size    |
  ;;                    + ------------------ +
  ;; 
  ;; Where size is one less than the size of the IDT is bytes, and
  ;; offset is the linear address of the IDT (not the physical
  ;; address, paging applies).
  ;;
  ;;
  ;; Table
  ;; -----
  ;;
  ;; There are 256 interrupt vectors, so the IDT should have 256
  ;; entries (gates), each gate corresponding to a specific interrupt
  ;; vector.
  ;; 
  ;; On 64-bit processors, the entries in the IDT are 16 bytes long
  ;; and form a table like this:
  ;;
  ;;              + ------------------------------ +
  ;;              | Address            | Content   |
  ;;              | ================== | ========= |
  ;;              | IDTR Offset + 0    | Entry 0   |
  ;;              | IDTR Offset + 16   | Entry 1   |
  ;;              | IDTR Offset + 32   | Entry 2   |
  ;;              | ...                | ...       |
  ;;              | IDTR Offset + 4080 | Entry 255 |
  ;;              + ------------------------------ +
  ;;
  ;; The corresponsing entry for a given interrupt vector is pointed
  ;; to in memory by scaling the vector by 16 and adding it to the
  ;; value in the offset field in the IDTR.
  ;;
  ;; 
  ;; Gates
  ;; -----
  ;;
  ;; A gate in the table has the following structure (using C for
  ;; clarity):
  ;;
  ;;   struct InterruptGate64 {
  ;;     uint16_t offset_1;        // offset bits 0..15
  ;;     uint16_t selector;        // a code segment selector in GDT
  ;;                               // or LDT
  ;;     uint8_t  ist;             // bits 0..2 holds Interrupt Stack
  ;;                               // Table offset, rest of bits zero.
  ;;     uint8_t  type_attributes; // Gate Type, Dpl, and P fields
  ;;     uint16_t offset_2;        // offset bits 16..31
  ;;     uint32_t offset_3;        // offset bits 32..63
  ;;     uint32_t zero;            // reserved
  ;;   };
  ;;
  ;; The Gate Type is a 4-bit value which defines the type of gate
  ;; this Interrupt Descriptor represents. In long mode there are two
  ;; valid type values:
  ;; 
  ;;   - 0b1110 or 0xE: 64-bit Interrupt Gate
  ;;   - 0b1111 or 0xF: 64-bit Trap Gate
  ;; 
  ;; DPL is a 2-bit value which defines the CPU Privilege Levels which
  ;; are allowed to access this interrupt via the INT
  ;; instruction. Hardware interrupts ignore this mechanism.
  ;;
  ;; P is the present bit. Must be set (1) for the descriptor to be
  ;; valid.
  ;;
  ;; 
  ;; Interrupt Service Routines
  ;; --------------------------
  ;;
  ;; Interrupt Service Routines must return from the interrupt using
  ;; the 'iretq' instruction.
  ;;
  ;; When the CPU calls the interrupt handlers, it changes the value
  ;; of the stack pointer to the IST (if specified). It then pushes
  ;; these values in this order: SS:RSP (original stack pointer),
  ;; RFLAGS, CS (code segment), RIP. CS is padded to form a quadword.
  ;; 
  ;; If the interrupt is an exception, the CPU will push an error code
  ;; onto the stack, padded with bytes to form a quadword.
  ;;
  ;;
  ;; List of interrupts
  ;; ------------------
  ;;
  ;; Here is a list of some exceptions and interrupts for x86_64:
  ;;
  ;; + ----------------------------------------------------------------- +
  ;; | Num  | Type       | Name            | Source                      |
  ;; | ==== | ========== | =============== | =========================== |
  ;; | 0x00 | Fault      | Divide Error    | Integer divide instructions |
  ;; | 0x01 | Trap/Fault | Debug Exception | Instruction, data, and I/0  |
  ;; |      |            |                 | breakpoints.                |
  ;; | 0x02 | Interrupt  | NMI Interrupt   | Nonmaskable external irq.   |
  ;; | 0x03 | Trap       | Breakpoint      | int3 instruction            |
  ;; | 0x04 | Trap       | Overflow        | int0 instruciton            |
  ;; | ...  | ...        | ...             | ...                         |
  ;; + ----------------------------------------------------------------- +
  ;;
  ;; For the full list goto the Intel manual, Volume 3 chapter 7.
  ;; 
  
  [bits 64]

  section .bss

 align 16
idt_start:                      ; a single entry is 16 bytes
     resb 256 * 16              ; 0 initialized
idt_end:

  section .data
  
idt_register:
    dw idt_end - idt_start - 1  ; limit (16 bits)
    dq idt_start                ; base  (64 bits)

  section .text
  
  ;; -----------------------------------------------------------------
  ;; Set a gate in the IDT
  ;;
  ;; Args:
  ;;   - r8b:  interrupt number
  ;;   - r9:   ISR address
  ;;   - r10w: code segment selector in GDT or LDT
  ;;   - r11b: gate type. 0 = interrupt gate, 1 = trap gate
  ;;   - r12b: DLP, a 2 bit value which defines the CPU privilege levels
  ;;           which are allowed to access this interrupt via INT instr.
  ;;   - r13b: IST: A 3-bit value which is an offset into the Interrupt
  ;;           Stack Table (can be 0)                  
idt_set_gate:
  push rax
  push rbx

  mov rax, idt_start            ; start of IDT
  mov rbx, r8                   ; interrupt number
  and rbx, 0xFF
  imul rbx, 16                  ; offset from idt_start
  add rax, rbx                  ; rax = gate address

  ;; Clean gate
  mov qword[rax], 0
  mov qword[rax + 8], 0
  
  mov rbx, r9                   ; offset_1
  and rbx, 0xFFFF
  or [rax], rbx

  mov rbx, r10                  ; selector
  and rbx, 0xFFFF
  shl rbx, 16
  or [rax], rbx

  mov rbx, r13                  ; ist
  and rbx, 0b111
  shl rbx, 32
  or [rax], rbx

  cmp r11b, 0                   ; gate type
  je .interrupt_gate

  mov rbx, 0b1111
  shl rbx, 40
  or [rax], rbx
  jmp .continue
  
  .interrupt_gate:

  mov rbx, 0b1110
  shl rbx, 40
  or [rax], rbx

  .continue:

  mov rbx, r12                  ; DLP
  and rbx, 0b11
  shl rbx, 45
  or [rax], rbx

  mov rbx, 1                    ; P bit
  shl rbx, 47
  or [rax], rbx

  mov rbx, r9                   ; offset_2
  shr rbx, 16
  and rbx, 0xFFFF
  shl rbx, 48
  or [rax], rbx

  mov rbx, r9                   ; offset_3
  shr rbx, 32
  or [rax + 8], rbx

  pop rbx
  pop rax
  ret
  
  ;; -----------------------------------------------------------------
  ;; Load the IDT
idt_load:

  cli
  
  mov r8b, 0                    ; interrupt number
  mov r9, isr0                  ; ISR address
  mov r10w, 0x8                 ; code segment selector in GDT
  mov r11b, 1                   ; 0 = interrupt, 1 = trap
  mov r12b, 0                   ; DLP
  mov r13b, 0                   ; IST
  call idt_set_gate

  mov r8b, 1
  mov r9, isr1
  call idt_set_gate

  mov r8b, 2
  mov r9, isr2
  mov r11b, 0                   ; 0 = interrupt, 1 = trap
  call idt_set_gate
  
  mov r8b, 3
  mov r9, isr3
  mov r11b, 1                   ; 0 = interrupt, 1 = trap
  call idt_set_gate
  
  mov r8b, 4
  mov r9, isr4
  call idt_set_gate
  
  mov r8b, 5
  mov r9, isr5
  call idt_set_gate
  
  mov r8b, 6
  mov r9, isr6
  call idt_set_gate
  
  mov r8b, 7
  mov r9, isr7
  call idt_set_gate

  mov r8b, 8
  mov r9, isr8
  call idt_set_gate
  
  mov r8b, 9
  mov r9, isr9
  call idt_set_gate
  
  mov r8b, 10
  mov r9, isr10
  call idt_set_gate
  
  mov r8b, 11
  mov r9, isr11
  call idt_set_gate
  
  mov r8b, 12
  mov r9, isr12
  call idt_set_gate

  mov r8b, 13
  mov r9, isr13
  call idt_set_gate
  
  mov r8b, 14
  mov r9, isr14
  call idt_set_gate
  
  mov r8b, 15
  mov r9, isr15
  call idt_set_gate
  
  mov r8b, 16
  mov r9, isr16
  call idt_set_gate
  
  mov r8b, 17
  mov r9, isr17
  call idt_set_gate
  
  mov r8b, 18
  mov r9, isr18
  call idt_set_gate
  
  mov r8b, 19
  mov r9, isr19
  call idt_set_gate
  
  mov r8b, 20
  mov r9, isr20
  call idt_set_gate
  
  mov r8b, 21
  mov r9, isr21
  call idt_set_gate
  
  mov r8b, 22
  mov r9, isr22
  call idt_set_gate
  
  mov r8b, 23
  mov r9, isr23
  call idt_set_gate
  
  mov r8b, 24
  mov r9, isr24
  call idt_set_gate
  
  mov r8b, 25
  mov r9, isr25
  call idt_set_gate
  
  mov r8b, 26
  mov r9, isr26
  call idt_set_gate
  
  mov r8b, 27
  mov r9, isr27
  call idt_set_gate
  
  mov r8b, 28
  mov r9, isr28
  call idt_set_gate
  
  mov r8b, 29
  mov r9, isr29
  call idt_set_gate
  
  mov r8b, 30
  mov r9, isr30
  call idt_set_gate
  
  mov r8b, 31
  mov r9, isr31
  call idt_set_gate

  mov r8b, 32
  mov r9, isr32
  call idt_set_gate
  
  mov r8b, 33
  mov r9, isr33
  call idt_set_gate

  lidt [idt_register]

  ret

  ;;
  ;; Interrupt service routines implementation
  ;;

  ;; -----------------------------------------------------------------
  ;; This gets called by all ISR
  ;; Prints the interrupt service number. Used for debugging
fault_handler:
  mov rsi, [rdi + 120]           ; ISR number
  mov rax, [rdi + 128]           ; Error code
  mov r8w, UART_COM1             ; Used for uart printing

  cmp rsi, 33                    ; Keyboard Interrupt
  jne .error
 
  call ps2_read_scancode
  
  ;; print the scancode in hex to verify it's working
  mov r9, idt_keyboard_message
  call uart_write_string
  mov r9, rax                    ; Scan code is in AL
  call uart_write_hex
  mov r9, `\n`
  call uart_write_char
  
  call pic_ack                  ; Send acknowledgement to PIC

  jmp .end

  .error:
  
  ;; Writes 'isr x, error x'
  mov r9, idt_fault_message
  call uart_write_string
  mov r9, rsi                   ; isr number
  call uart_write_hex
  mov r9, idt_error_message
  call uart_write_string
  mov r9, rax                   ; error
  call uart_write_hex
  mov r9, `\n`
  call uart_write_char
  
  .end:
  ret

idt_fault_message:  db `isr `, 0
idt_error_message:  db `, error `, 0
idt_keyboard_message:  db `key `, 0
  
  ;; This is a common ISR stub. It saves the processor state, sets up
  ;; for kernel mode segments, calls the C-level fault handler, and
  ;; finally restores the stack frame.
isr_common_stub:
  cli
  
  ;; save all
  push r15
  push r14
  push r13
  push r12
  push r11
  push r10
  push r9
  push r8
  push rdi
  push rsi
  push rbp
  push rbx
  push rdx
  push rcx
  push rax
  
  mov rdi, rsp   ; pass stack frame
  call fault_handler

  pop rax
  pop rcx
  pop rdx
  pop rbx
  pop rbp
  pop rsi
  pop rdi
  pop r8
  pop r9
  pop r10
  pop r11
  pop r12
  pop r13
  pop r14
  pop r15
  
  add rsp, 16     ; Cleans up the pushed error code and pushed ISR number

  sti
  iretq

  ;; Some isr push a 32 bit error code. Here we manually push a 0
  ;; value so that the isr handler can expect to have the save number
  ;; of elements in the stack to pop.
  
  ;;  0: Divide Error fault
isr0:
  push qword 0    ; push a dummy error code to keep a uniform stack frame
  push qword 0    ; isr number
  jmp isr_common_stub

  ;;  1: Debug exception fault / trap
isr1:
  push qword 0                   ; dummy value
  push qword 1                   ; isr number
  jmp isr_common_stub

  ;; 2: Non maskable external interrupt
isr2:
  push qword 0                   ; dummy value
  push qword 2                   ; isr number
  jmp isr_common_stub
  
  ;; 3: Breakpoint trap
isr3:
  push qword 0                   ; dummy value
  push qword 3                   ; isr number
  jmp isr_common_stub
  
  ;; 4: Overflow trap
isr4:
  push qword 0                   ; dummy value
  push qword 4                   ; isr number
  jmp isr_common_stub

  ;; 5: BOUND range exceeded fault
isr5:
  push qword 0                   ; dummy value
  push qword 5                   ; isr number
  jmp isr_common_stub

  ;; 6: Invalid Opcode fault
isr6:
  push qword 0                   ; dummy value
  push qword 6                   ; isr number
  jmp isr_common_stub

  ;; 7: Device not available (no main coprocessor) fault
isr7:
  push qword 0                   ; dummy value
  push qword 7                   ; isr number
  jmp isr_common_stub

  ;; 8: Double fault abort
isr8:
  push qword 8                   ; isr number
  jmp isr_common_stub

  ;; 9: Coprocessor Segment Overrun (reserved) fault
isr9:
  push qword 0                   ; dummy value
  push qword 9                   ; isr number
  jmp isr_common_stub

  ;; 10: Invalid TSS fault
isr10:
  push qword 10                   ; isr number
  jmp isr_common_stub

  ;; 11: Segment not present fault
isr11:
  push qword 11                   ; isr number
  jmp isr_common_stub

  ;; 12: Stack-segment fault
isr12:
  push qword 12                   ; isr number
  jmp isr_common_stub

  ;; 13: General Protection fault
isr13:
  push qword 13                   ; isr number
  jmp isr_common_stub

  ;; 14: Page fault
isr14:
  push qword 14                   ; isr number
  jmp isr_common_stub

  ;; 15: (intel reserved, do not use)
isr15:
  push 0                         ; dummy value
  push qword 15                   ; isr number
  jmp isr_common_stub

  ;; 16: x87 FPU Floating-point error (math fault)
isr16:
  push 0                         ; dummy value
  push qword 16                   ; isr number
  jmp isr_common_stub

  ;; 17: Alignment Check fault
isr17:
  push qword 17                   ; isr number
  jmp isr_common_stub

  ;; 18: Machine Check Abort
isr18:
  push 0                         ; dummy value
  push qword 18                   ; isr number
  jmp isr_common_stub

  ;; 19: SIMD Floating-point exception fault
isr19:
  push 0                         ; dummy value
  push qword 19                   ; isr number
  jmp isr_common_stub

  ;; 20: virtualization exception fault
isr20:
  push 0                         ; dummy value
  push qword 20                   ; isr number
  jmp isr_common_stub

  ;; 21: Control Protection Exception fault
isr21:
  push qword 21                   ; isr number
  jmp isr_common_stub

  ;; 22: Intel reserved. Do not use.
isr22:
  push qword 0
  push qword 22                   ; isr number
  jmp isr_common_stub

  ;; 23: Intel reserved. Do not use.
isr23:
  push qword 0
  push qword 23                   ; isr number
  jmp isr_common_stub

  ;; 24: Intel reserved. Do not use.
isr24:
  push qword 0
  push qword 24                   ; isr number
  jmp isr_common_stub

  ;; 25: Intel reserved. Do not use.
isr25:
  push qword 0
  push qword 25                   ; isr number
  jmp isr_common_stub

  ;; 26: Intel reserved. Do not use.
isr26:
  push qword 0
  push qword 26                   ; isr number
  jmp isr_common_stub

  ;; 27: Intel reserved. Do not use.
isr27:
  push qword 0
  push qword 27                   ; isr number
  jmp isr_common_stub

  ;; 28: Intel reserved. Do not use.
isr28:
  push qword 0
  push qword 28                   ; isr number
  jmp isr_common_stub
  
  ;; 29: Intel reserved. Do not use.
isr29:
  push qword 0
  push qword 29                   ; isr number
  jmp isr_common_stub
  
  ;; 30: Intel reserved. Do not use.
isr30:
  push qword 0
  push qword 30                   ; isr number
  jmp isr_common_stub

  ;; 31: Intel reserved. Do not use.
isr31:
  push qword 0
  push qword 31                   ; isr number
  jmp isr_common_stub
  
  ;; 32: Mouse Interrupt
isr32:
  push qword 0
  push qword 32                   ; isr number

  ;; Does nothing special for now
  jmp isr_common_stub
  
  ;; 33: Keyboard Interrupt
isr33:
  push qword 0
  push qword 33                   ; isr number
  jmp isr_common_stub
  
